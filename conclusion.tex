I have shown you the power of s-expressions and referentially transparent functions, and how their 
compositions are essential to solving complex problems. I have also shown that the \keyword{turing-complete}ness
of a programming language is not dependent on the existence of mutations, variable reassignments, conditional statements 
(which are not the same as conditional expressions), iterative loops, and other imperative constructs. If the chapters here didn't convince you, 
try converting some of the sample code in this book to their imperative counterparts. You will see how much more concise functional programming really
is when compared to imperative programming.

As you've probably already realized, functional programming is not a "do this, then do that" paradigm  (that's imperative programming). 
Functional programming is a "I declare this, I declare that" paradigm. Constructing a solution based on the definition of things is much easier than
constructing solutions based on (side-effecting) instructions. Lastly, solving problems by just defining functions often lead to not only more concise solutions, but also solutions that are easier to reason about.