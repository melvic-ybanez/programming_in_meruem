\section{What is Recursion?}
\ikeyword{Recursion} is an approach to solving a problem by using a function that is composed of simpler instances of the same function. It is essentially similar to constructing a function that calls itself. 

One common example is the recursive, mathematical definition of \keyword{factorial}. The \ikeyword{factorial} of a positive integer $n$ is the product of $n$ and the \keyword{factorial} of $1$ less than $n$. This is a recursive definition because the term being defined (which is $factorial$) appears, as an important element, in it's definition.

Here's a sample implementation of a factorial function in Meruem:

\begin{Meruem}
(defun factorial (n)
  (if (= n 0)
    1
    (* n (factorial (dec n)))))

(defun main (args)
  (println (factorial 
             (to-int (head args)))))
\end{Meruem}

Before we discuss the \code{factorial} function itself, let's first take a look at our main function here. The main function applies the \code{head} function --- which takes a list and returns its first element --- to \code{args}. Then it converts the result (which, in this case, is a string) to \code{int}. Next, it applies the \code{factorial} function to the integer result. (\code{factorial} can only be applied to integers so we had to convert the \code{head} of \code{args} to \code{int} first.) Lastly it prints the result of calling \code{factorial}. Basically, what we're doing is telling the user to pass as a command line argument the value \code{factorial} is to be applied to. With this, we can run the program multiple times with different arguments without having to modify the code.

Now, let's talk about the \code{factorial} function. It takes an integer and checks if its value is \code{0}. If it is \code{0}, then the function returns 1. Otherwise, the function returns the product of the integer \code{n} and the result of applying itself to the value of \code{n} decreased by 1. In this case, the \code{factorial} function is performing a recursive call. Let's try running it a few times to see if it will behave as we wanted it to:

\begin{REPL}
$  java -jar $MERUEM_HOME/meruem.jar factorial 5
120
$ java -jar $MERUEM_HOME/meruem.jar factorial 10
3628800
$ java -jar $MERUEM_HOME/meruem.jar factorial 4
24
\end{REPL}

In order to have an idea of what's really happening when we ran \code{factorial}, you can substitute each of the argument values for every parameter \code{n} in each call to \code{factorial}. For instance, here's what happens when you execute \code{(factorial 5)}:

\begin{flalign*}
factorial(5) &= 5 \times factorial(4) \\
&= 5 \times (4 \times factorial(3)) \\
&= 5 \times (4 \times (3 \times factorial(2))) \\
&= 5 \times (4 \times (3 \times (2 \times factorial(1)))) \\
&= 5 \times (4 \times (3 \times (2 \times (1 \times factorial(0))))) \\
&= 5 \times (4 \times (3 \times (2 \times (1 \times 1)))) \\
&= 120
\end{flalign*}

As you can see, we couldn't compute for the factorial of 5 without knowing the factorial of 4 first. And we couldn't get the factorial of 4 without calling the factorial of 3, and so on. When we finally got to $factorial(0)$ --- or \code{(factorial 0)} in Meruem --- the recursive calling stopped. That is because we hit the \keyword{base case} (I'll explain this in a minute), which says that the factorial of 0 is 1. When $factorial(0)$ returned 1, $factorial(1)$ resumed it's computation. When $factorial(1)$ completed and returned, $factorial(2)$ resumed, and so on. Eventually, the original call --- $factorial(5)$ --- returned and we had our result.

A recursive function should have a base case. A \ikeyword{base case} is the case in which the result can be computed without resorting to a recursive call. In our factorial function, the base case happens when the input is 0. You can say that $factorial(0)$ is the simplest instance of the factorial function. If we remove the base case of the factorial function, calling it would cause an \keyword{infinite recursion}, because calling $factorial(0)$ would result to $0 \times factorial(-1)$, instead of $1$, $factorial(-1)$ resolves to $-1 \times factorial(-2)$, and so on.
