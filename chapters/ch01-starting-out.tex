\section{What is Meruem?}
\ikeyword{Meruem} is a dynamically-typed, interpreted programming language that supports both \keyword{functional programming} and \keyword{metaprogramming}, and runs on top of the \keyword{Java Virtual Machine}(JVM).

Meruem is also a \keyword{Lisp} dialect. That means it has most, if not all, of the characteristics common to all Lisps, like \keyword{homoiconicity}, \keyword{macros}, and a small, simple and elegant core.

\section{Why learn Meruem?}
Meruem will change the way you think about programs, programming, and problems in general. The things that you will learn from this book will still be applicable to your day-to-day job as a programmer, even if you will be using a different and more mainstream programming language. This is because learning Meruem is not just learning a new programming language, it's learning completely new programming paradigms. Knowing different programming paradigms (imperative, OOP, FP, etc) is always a good thing since it would give you different ways of solving problems. After you've learned Meruem, you'd realize that there's more to programming than just \keyword{imperative programming}.

\section{Overview of Programming Paradigms}
Before we continue, let us first make a brief discussion about the different programming paradigms. We are not going to talk about all of them, though. We are just going to talk about the ones most programmers are familiar with (imperative, OOP), and the ones this book are going to focus on (functional programming and metaprogramming).

In the following subsections, we are going to show you some code samples from different programming languages. If you are not familiar with these languages, don't worry. Knowing them is not required. That said, we strongly recommend that you try reading these subsections (or at least the explanation parts).

\subsection{Imperative Programming}
In \ikeyword{Imperative programming}, you give the computer a sequence of statements for it to perform. Each of these statements can cause side effects. \ikeyword{Side effects} are changes (on a state or something) that occur in some place (like outside of a function being invoked) when a function, command or statement is invoked or executed. For example, the following code will print the string \code{Hello World} to the screen:
\begin{Python}
	print "Hello World"
\end{Python}
That is a Python snippet. It is a side effecting statement, because something is printed when that line of code is run. The state of the console has changed. Another example is the modification of variable values or references: 
\begin{Python}
	x = int(raw_input('Enter a number')) (*@\label{line:x-init}@*)
	if x < 20:
		x = 7 (*@{\label{line:x-new}@*)
\end{Python}
The above code takes an integer (actually it's an integer parsed from a string) from the keyboard, and store it to the variable \code{x}. If \code{x} is less than 20, then set it to 7. Line~\ref{line:x-new} is a side effecting assignment statement since you are destroying the old value and replacing it with a new one, making the value of \code{x} different from before. This is called a \keyword{desctructive assignment}. Line~\ref{line:x-init}, however, is not a side effecting statement since assigning an initial value to a variable is not the same as changing it. This kind of assignment is known as \keyword{initialization}.

You'll learn more about side effects later in the book. (Though you won't learn much about imperative programming in general here.)

\subsection{Object-oriented Programming (OOP)}
In \ikeyword{Object-oriented programming}, you focus on designing data structures that contain both the data and the functions that can operate on these data. Most object-oriented languages also support imperative programming, and in some cases, we only think of them as either imperative  or OO languages, even though they are (to some extent) both. Many languages are actually multi-paradigms (i.e. they support more than one paradigm), but they tend to favour one paradigm over the others. 

Java is a good example of a language that supports both imperative and OOP. In Java~8, you can even do a little bit of functional programming. Java is usually thought of as an object-oriented language. If you program in Java, you are expected to do it the OOP way. For instance, if you want to create a data structure that represents a person, you can do it like this:
\begin{Java}
	public class Person {
		private String name;
		private int age;
		
		public void setName(String name) {
			this.name = name;		
		}
		
		public void setAge(int age) {
			this.age = age;		
		}
		
		public String getName() {
			return name;		
		}
		
		public int getAge() {
			return age;		
		}
	}
\end{Java}
The code above is called a \keyword{class}, and most OO languages have it. Classes can contain both the variables (in this case, \code{name} and \code{age}) and the functions (in this case, \code{setName}, \code{getAge}, etc.) or \keyword{methods}. In order to use a class, you usually have to instantiate it. \ikeyword{Instantiation} is the process of converting a class into an object or \keyword{instace of a class}. To instantiate a class in Java, you use the \code{new} operator, as follows:
\begin{Java}[3]
	Person bob = new Person();
	Person juan = new Person();
\end{Java}
As you can see, you can create more than one object using a single class. That is because a class is just a blueprint of an object, and you can use the same blueprint many times to create its instances. Now you can use \code{bob} like this:
\begin{Java}[5]
	bob.setName("Bob");
	bob.setAge(24);
	System.out.println(bob.getName());
	System.out.println(bob.getAge());
\end{Java}

There are so many things to learn in object-oriented programming, such as \keyword{inheritance}, \keyword{polymorphism}, \keyword{encapsulation}, etc. The in-depth discussions of these topics are unfortunately outside the scope of this book.

\subsection{Functional Programming}
\ikeyword{Functional Programming} is about writing programs that consist mostly of functions and/or expressions. Functions in functional languages are \keyword{first-class citizens}, which means that you can consider or treat them like any other values. First-class functions can be passed as values to variables, or as actual arguments to other functions. You can also return functions from other functions. Basically whatever it is you can do with an ordinary value like an integer \code{107} or a string \code{"Hello World"} can be done with first-class functions.

We are not going to show any examples here, since this is one of the main things this book will be focusing on, anyway. You'll see a lot of examples through-out the book.

\subsection{Metaprogramming}
\ikeyword{Metaprogramming} is the writing of code that takes other code as input values, or produces other code. In other words, in metaprogramming, programs can be treated as data. So you can pass/return code to/from other functions. It's like in functional programming, except that you don't have to wrap things in functions in order to pass them around. 

Lisps are quite known for their support for metaprogramming using \keyword{macros}. In this book, you will learn the macro system of Meruem. Remember, Meruem too is a Lisp.  

\section{Installing Meruem}
To program in Meruem, you need to install Java and download the Meruem interpreter.

\subsection{The Java Virtual Machine}
As I've said above, Meruem runs on the Java platform, which is a JVM (sometimes I just refer to it as "the JVM"). To be more accurate, the current version of Meruem actually gets ran by the Scala programming language, which runs on top of the JVM. What I mean by that is that the interpreter of Meruem is written in Scala. 

But, just what is a JVM? 

According to Wikipedia, a JVM is "an abstract computing machine that enables a computer to run a Java program". Essentially, without a JVM, we can't run Java programs. 

So how do Scala programs run on it if it only understands Java bytecode? Simple, the Scala compiler generates Java bytecode. And since Meruem is written in Scala, then a Meruem code will eventually be converted to Java bytecode. 

So we need to install a JVM in order to run our Meruem interpreter. To do that, we install a \keyword{Java Runtime Environtment}(JRE). Installing a JRE was what I meant earlier by installing Java. A JRE contains the JVM, libraries, and some other things we shouldn't worry about in this book. There are many instructions on the web on how to install a Java runtime environment on different platforms, such as this one: \url{ https://www.java.com/en/download/help/download_options.xml}

\begin{noteparagraph}
	There is also what is known as a \keyword{Java Development Kit}(JVM). You have to 	 
	install it if you want to develop Java programs and not just being able to run them. A JVM 
	already contains a JRE so you don't need to install both.
\end{noteparagraph}

\subsection{Downloading the interpreter}
When you installed the JRE, you've already installed the JVM as well. . However, the JVM alone is not enough to run Meruem programs. That's because it only understands Java bytecodes

