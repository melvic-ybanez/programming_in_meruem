In this chapter, we are going to make use of the REPL only. We are not going to use Winter (or any text editor you have right now). If you haven't already installed the REPL, please go back to section~\ref{sec:installing-meruem} and follow the instructions on how to install Meruem before proceeding. Remember, the Meruem distribution is already bundled with a REPL.

\section{Data Types}
Programming always involves manipulating data. For instance, writing a program that adds two random numbers involves working on numbers. Reading the contents of a file involves the manipulation of files and strings. An enrolment system requires the presence of data that represent the student information, the class schedules, and others. Even the \code{Hello World} program that we wrote earlier wouldn't even be completed if we didn't know what data to print to the screen. Whatever it is you want to do, you need some data.

Now, the thing about data is they don't all have the same classifications, and the operations that you can perform on a data depend on the classification of that data. For example, you can add a number to another number but you can't add a number to a student information. (That wouldn't really make sense.) This classification of data is known as a \keyword{data type}.

A \ikeyword{data type} tells you how a thing is classified, what set of values belongs to this type, and what operations can be performed on it. Meruem has a short list of supported data types. Let's discuss each of them, starting with the \code{Number} types.

\subsection{Number}
\code{Number} types are, well, numbers. You can perform mostly mathematical operations on them. Meruem has four number types: \code{Integer}, \code{Long}, \code{Float}, \code{Double}. The differences of these types will be discussed in the following subsections.

\subsubsection{Integer}
\code{Integer} types (or simple \code{Integer}s) are signed whole numbers (including 0). The "signed" indicates the inclusion of negative numbers. An integer can also be referred to as an \code{int}. To see what integers look like, fire up the REPL and enter the following code:

\begin{REPL}
meruem> 10
10
meruem> -28
-28
meruem> 0
0
\end{REPL}

These are examples of integer literals. A \ikeyword{literal} is a value that was written directly in the source code, and not one shown to be stored in a data structure or variable, or treated as a return value from a function or expression. 

Integer literals evaluate to themselves. This is why when you entered \code{10}, you also got the result of \code{10}. 

\subsubsection{Long}
\code{Long} numbers are just like integers, except that they are \code{long}er:

\begin{REPL}
meruem> 456@L
456
meruem> 456@l
456
meruem> 46466464@L
46466464
\end{REPL}

The only thing that makes \code{long}'s syntax different than \code{int}'s is the \code{@L} or \code{@l} at the end of the numbers. The \code{@L} tells the interpreter that the number preceding number should be interpreted as a long, and not an integer. The \code{L} can be either in lower or upper case. These suffixes are removed when \code{long} literals are evaluated. 

Now you might be wondering when to use \code{long} instead of \code{int}. The answer is simple: data types have limitations, not only in their structure but also on the range of values they can take. Integers can only take values ranging from $-2^{32}$ to $2^{31}-1$. Try inputing a value larger than the maximum value of an integer and you will get an error:

\begin{REPL}
meruem> 545345453535353
Exception in thread "main" java.lang.NumberFormatException: For input string: "545345453535353"
	at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
	at java.lang.Integer.parseInt(Integer.java:583)
	............
\end{REPL}

That is only a part of a longer error message. The error occurred because you provided a number that is greater than the maximum value of an integer. If you wanted to manipulate on numbers that big you should have used a long:

\begin{REPL}
meruem> 545345453535353@l
545345453535353
meruem>
\end{REPL}

\subsubsection{Float}
A \code{float} is a number type that can contain decimal digits. You can write \code{float} by appending \code{@f} (or \code{@F}) to the a number:

\begin{REPL}
meruem> 454@f
454.0
meruem> 453.454@F
453.454
\end{REPL}

Notice that even if you don't include some decimal digits, the interpreter will still treat the number as if there's a "\code{.0}" at the end.

\subsubsection{Double}
A \code{double} is just like a float, except that it has twice the precision and can hold a much bigger value. As you've probably already guessed, a \code{double} ends with either \code{@d} or \code{@D}:

\begin{REPL}
meruem> 5453.@d
5453.0
meruem> 654654.899898@D
654654.899898
\end{REPL}

I encourage you to do more experiments on your own. After all, the best way to learn a programming language is to used it.

\subsection{Boolean}
A \code{boolean} accepts only one of the two possible values. In Meruem, these values are \code{true} and \code{false}: (In other languages that don't support boolean types, they are simulated using the values \code{0} and \code{1}). 

\begin{REPL}
meruem> true
true
meruem> false
false
meruem>  
\end{REPL}

\subsection{Character}
A \code{character} (also referred to as \code{char}) is any alpha-numeric (letter or number) character or special symbol that is preceded by a \code{\textbackslash} character:

\begin{REPL}
meruem> \a
\a
meruem> \6 
\6
meruem> \?
\?
meruem> 
\end{REPL}

One thing to notice is that even a number gets turned into a \code{char} when preceded by a \code{\textbackslash} character. A limitation of this type is that it can't hold multiple characters:

\begin{REPL}
meruem> \hello
An error has occurred. Parse Failure: string matching regex `\z' expected but `e' found
Source: .home.melvic.meruem.meruem.prelude [11:53}]
(defun truthy? (expr) (and (!= expr false) (!= expr nil)))

                                                    ^
meruem> ; this is a comment
\end{REPL}

Here, the interpreter is telling you that it can't parse the input properly. (In this chapter, we shouldn't worry too much about the details of the errors.)

\begin{noteparagraph}
The evaluated form of a character in the REPL contains a \code{\textbackslash} at the beginning. However, when you run a source file that prints a character to the console, you shouldn't see the \code{\textbackslash}.
\end{noteparagraph}
