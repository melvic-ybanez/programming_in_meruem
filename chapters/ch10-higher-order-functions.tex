A \ikeyword{higher-order function} is a function that can take other functions as arguments or return a function as a result (or both). Higher-order functions are the bread and butter of functional programming. You've already seen some examples of higher-order functions in the past chapters, like \code{lists.filter}, \code{lists.map}, and \code{lists.fold-left}. In this chapter you are going to learn how to write you own higher-order functions.

\section{Functions as Parameters}
Let's start this section with the following example:

\begin{REPL}
(import "math")

(defun compute (f) 
  (f (math.random) (math.random)))
\end{REPL}

The \code{compute} function takes one function and apply it to two random numbers. The user of this function gets to decide what function to apply to these numbers. For instance, we can decide to make \code{compute} add or multiply the two random numbers. The following code shows two functions that make use of \code{compute}:

\begin{REPL}
(defun sum ()
  (compute (lambda (a b) (+ a b))))
  
(defun product ()
  (compute (lambda (a b) (* a b))))
\end{REPL}

\code{sum} passes a lambda --- that takes two arguments and return their sum --- to \code{compute}. This gets substituted for the parameter \code{f} in \code{compute}. In other words, calling \code{sum} would be equivalent to evaluating the following expression:

\begin{REPL}
((lambda (a b) (+ a b)) 
	(math.random) (math.random))
\end{REPL}

The same thing can be said about \code{product}. Here's the whole code:
\begin{REPL}
(import "math")

(defun compute (f) 
  (f (math.random) (math.random)))

(defun sum ()
  (compute (lambda (a b) (+ a b))))

(defun product ()
  (compute (lambda (a b) (* a b))))
\end{REPL}

Save it as \code{hofs.mer} and test it in the REPL, as follows:

\begin{REPL}
meruem> (import "hofs")
SomeModule(hofs, MutableList(/home/melvic/meruem/lib/prelude, /home/melvic/meruem/lib/math), ArrayBuffer(product, module, sum, compute)})
meruem> (hofs.sum)
0.8586173428606856
meruem> (hofs.product)
0.14223037787589593
\end{REPL}

\section{Functions as Return Values}
Here's an example of a function that returns a function as the result of computation:

\begin{REPL}
(defun my-concat (str1)
  (lambda (str2)
    (++ str1 str2)))
\end{REPL}

In the example above, \code{my-concat} takes an argument (stored in parameter \code{str1}) and returns a lambda that takes an argument (stored in \code{str2}) and returns the concatenation of \code{my-concat}'s and this lambda's parameters. Here's how we can use it:

\begin{REPL}
meruem> (import "hofs")
SomeModule(hofs, MutableList(/home/melvic/meruem/lib/prelude, /home/melvic/meruem/lib/math), ArrayBuffer(product, my-concat, module, sum, compute)})
meruem> ((hofs.my-concat "hello") "world")
"helloworld"
meruem> (def apples-and (hofs.my-concat "apples and "))
nil
meruem> (apples-and "oranges")
"apples and oranges"
meruem> (apples-and "papaya")
"apples and papaya"
meruem> (apples-and "dinosaurs")
"apples and dinosaurs"
\end{REPL}

The great advantage of returning a function from another function is that you can create a new function "on the fly", like our \code{apples-and} in the example.